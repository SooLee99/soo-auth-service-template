# 스프링 시큐리티는 OAuth 로그인을 어떤 식으로 처리할까

그리고 이 프로젝트는 어디를 커스텀해서 “회원가입/로그인/정책/세션관리”를 붙였을까

OAuth를 붙이는 작업은 겉으로는 “로그인 버튼 하나 추가”처럼 보이지만, 실제로는 프레임워크가 꽤 많은 일을 대신해준다.
다만 그 덕분에 놓치기 쉬운 지점도 생긴다. 예를 들어, 로그인 성공 이후에 해야 할 정책(디바이스 차단, 감사 로그, 세션 매핑)은 스프링 시큐리티가 자동으로 해주지 않는다.

---

## 1) Set up: 애플리케이션 실행 시 OAuth가 동작하기 위해 준비되는 것들

OAuth가 동작하려면 “플랫폼별 설정(카카오/구글/네이버)”이 런타임에서 쓰일 수 있도록 정규화돼야 한다.
스프링 시큐리티는 이를 위해 설정 파일을 읽어 **ClientRegistration**이라는 공통 모델을 만든다.

### 1-1. 설정 파일은 OAuth2ClientProperties로 바인딩된다

우리가 `application-oauth.yml`에 작성한 값들(예: client-id, client-secret, scope, redirect-uri, provider endpoint)은 애플리케이션 시작 시점에 **OAuth2ClientProperties**로 바인딩된다.

여기서 중요한 포인트는 하나다.

* 어떤 플랫폼은 스프링이 기본 provider 정보를 제공해서 설정이 간단하고
* 어떤 플랫폼은 기본 provider에 없거나 추가 정보가 필요해 provider 설정을 직접 적어야 한다

즉, “네이버/카카오가 더 많은 설정을 요구하는 이유”는 프레임워크가 제공하는 기본값 범위 차이 때문인 경우가 많다.

### 1-2. provider마다 ClientRegistration이 생성된다

스프링 시큐리티는 provider마다 `ClientRegistration`을 만든다.
이 객체는 플랫폼마다 달라 보이는 OAuth 설정을 아래처럼 “표준 항목”으로 통일한다.

* authorization endpoint (로그인 화면)
* token endpoint (code → token 교환)
* userinfo endpoint (token → 사용자 정보 조회)
* clientId/clientSecret
* redirect URI template
* scopes
* userNameAttributeName (사용자 식별 키)

즉, 런타임에서는 “카카오든 구글이든 네이버든” 동일한 타입(ClientRegistration)으로 다룬다.

### 1-3. ClientRegistrationRepository에 저장되고 registrationId로 조회된다

생성된 ClientRegistration들은 `ClientRegistrationRepository`(대개 InMemoryClientRegistrationRepository)에 저장된다.
그리고 이후 요청에서 `/oauth2/authorization/{registrationId}`의 `{registrationId}`로 ClientRegistration을 찾는다.

이 흐름을 알면, OAuth가 “설정 파일 기반으로 자동 동작”하는 이유가 명확해진다.
프레임워크는 이미 필요한 정보를 표준 모델로 만들어 저장해두었고, 요청이 오면 그 저장소에서 꺼내 쓰는 방식이다.

---

## 2) OAuth 로그인 요청 처리: 필터 체인에서 벌어지는 두 단계

OAuth는 크게 두 단계로 나뉜다.

1. **Authorization Request**: 우리 서버가 플랫폼 로그인 화면으로 redirect
2. **Authorization Response**: 플랫폼이 우리 서버로 callback → code를 token으로 교환 → userinfo 조회

이 모든 과정의 중심은 **컨트롤러가 아니라 필터 체인**이다.

---

## 3) 1단계: /oauth2/authorization/{registrationId} 요청 처리

### 3-1. OAuth2AuthorizationRequestRedirectFilter가 redirect를 만든다

사용자가 “구글 로그인/카카오 로그인” 버튼을 누르면 보통 아래 URL로 요청이 들어온다.

* `/oauth2/authorization/google`
* `/oauth2/authorization/kakao`
* `/oauth2/authorization/naver`

이 요청은 `OAuth2AuthorizationRequestRedirectFilter`가 잡는다.
이 필터는 내부에서:

1. URL에서 registrationId를 추출하고
2. ClientRegistrationRepository에서 해당 ClientRegistration을 찾고
3. OAuth2AuthorizationRequest를 생성한 뒤
4. state(및 필요한 보안 파라미터)를 저장하고
5. authorization endpoint로 redirect 한다

여기서 state는 단순한 옵션이 아니라, **콜백 위조/CSRF성 공격을 막는 검증 키**다.
스프링 시큐리티가 state 생성/저장/검증 흐름을 자동으로 구성해주기 때문에, 우리가 직접 구현하지 않아도 된다.

---

## 4) 2단계: /login/oauth2/code/{registrationId} 콜백 처리

플랫폼 로그인과 동의가 끝나면, 플랫폼은 redirect URI로 우리 서비스에 돌아온다.

* `/login/oauth2/code/google`
* `/login/oauth2/code/kakao`
* `/login/oauth2/code/naver`

### 4-1. OAuth2LoginAuthenticationFilter가 콜백을 ‘인증 요청’으로 바꾼다

이 콜백 요청은 `OAuth2LoginAuthenticationFilter`가 처리한다.
필터는:

1. 콜백 파라미터에서 code/state 등을 추출하고
2. 이전 단계에서 저장한 AuthorizationRequest(state)를 꺼내 검증한 뒤
3. OAuth2LoginAuthenticationToken(미인증)을 만들고
4. AuthenticationManager.authenticate(...)에 위임한다

즉, OAuth에서도 구조는 같다.

> 필터가 토큰을 만들고 → 인증은 AuthenticationManager에게 위임한다.

---

## 5) code → token → userinfo는 OAuth2LoginAuthenticationProvider가 처리한다

AuthenticationManager는 여러 Provider 중 “OAuth2LoginAuthenticationToken을 처리할 수 있는 Provider”를 선택한다.
이때 선택되는 것이 `OAuth2LoginAuthenticationProvider`다.

### 5-1. code를 access token으로 교환한다

Provider는 내부적으로 `DefaultAuthorizationCodeTokenResponseClient`를 사용해 token endpoint로 요청을 보내고 access token을 얻는다.

이 부분을 알고 나면, OAuth 구현에서 흔히 하는 착각 하나가 정리된다.

* “내 코드가 토큰 교환을 했다”가 아니라
* “프레임워크가 이미 토큰 교환을 수행하고, 나는 그 결과를 후처리한다”에 가깝다

### 5-2. access token으로 사용자 정보를 가져온다

access token을 얻으면 `DefaultOAuth2UserService`가 userinfo endpoint를 호출해 사용자 정보를 가져온다.
이 결과는 provider마다 형태가 다른 `attributes(Map)`로 들어온다.

---

# 6) 이 프로젝트의 커스텀 구현: 어디를 확장해서 도메인 요구사항을 붙였을까

스프링 시큐리티는 “외부 플랫폼 인증”과 “사용자 정보 로딩”까지는 해준다.
하지만 아래는 우리 서비스가 결정해야 한다.

* 이 사용자를 우리 서비스에서 누구로 저장할지(회원가입/로그인 업서트)
* 플랫폼마다 제공하는 필드가 다른데 어떤 공통 필드로 저장할지
* 디바이스 차단, 로그인 감사 로그, 세션 매핑 같은 운영/보안 정책

현재 프로젝트는 이를 다음처럼 분리한다.

* **UserAccountService**: provider별 사용자 정보 추출 + 업서트
* **OAuth2LoginSuccessHandler**: 인증 성공 이후 정책/운영 후처리

---

## 6-1. UserAccountService: provider별 JSON을 공통 모델로 만드는 단계

### (1) extractUserInfo(token): provider마다 다른 attributes를 표준화

`OAuth2AuthenticationToken`에는 provider가 누구인지, 그리고 userinfo로 받은 attributes가 담겨 있다.

프로젝트에서는 `extractUserInfo(token)`에서:

* registrationId(kakao/naver/google)로 provider를 구분하고
* provider별 JSON 구조에서 필요한 값들을 추출해
* `OAuthUserInfo` 같은 공통 모델로 만든다

예를 들어:

* 어떤 provider는 최상위에 id가 있고
* 어떤 provider는 `response` 내부에 id가 있고
* 어떤 provider는 이메일 제공이 optional일 수 있다

이 레이어가 없으면 provider가 추가될 때마다 이후 로직이 망가지기 쉽다.
반대로 이 레이어가 있으면 provider가 늘어도 “매핑 케이스만 추가”하면 된다.

### (2) upsertFromOAuth2(token): oauth_identity를 기준으로 안정적인 계정 연결

프로젝트에서 회원 식별의 기준은 email이 아니라 다음이다.

* `(provider, providerUserId)` 조합이 유니크
* 이것이 `oauth_identity` 테이블의 핵심 제약(uq_oauth_identity_provider_user)

이 구조의 장점은 명확하다.

* 이메일이 없는 provider도 처리 가능
* 이메일이 변경되더라도 계정 연결이 흔들리지 않는다
* 하나의 UserAccount에 여러 provider 연결도 가능해진다

그리고 여기서 중요한 디테일은 **동시성(레이스 컨디션) 처리**다.

* 동시에 로그인 요청이 들어오면 oauth_identity insert에서 unique 충돌이 날 수 있다
* 그래서 DataIntegrityViolationException을 잡고 재조회하여 최종 userId를 확정한다

이 패턴은 운영에서 “중복 생성” 문제를 줄이는 데 정말 중요하다.

---

## 6-2. OAuth2LoginSuccessHandler: 인증 성공 이후 ‘정책/운영’ 후처리

`OAuth2LoginSuccessHandler`는 “OAuth 인증이 완전히 성공한 다음” 호출된다.
여기서부터는 시큐리티 인증 문제가 아니라, 서비스 정책 문제다.

프로젝트 핸들러 흐름은 다음처럼 구성되어 있다.

### (1) provider 식별

registrationId(kakao/naver/google)를 내부 enum(AuthProvider)으로 변환해 공통 처리한다.

### (2) provider 사용자 → 우리 userId 업서트

`userAccountService.upsertFromOAuth2(token)`으로:

* providerUserId 추출
* oauth_identity 연결
* user_account 생성/갱신
* 최종 userId 확정

### (3) 디바이스 차단 정책

차단이면:

* 세션 삭제(강제 로그아웃)
* 로그인 실패 기록(LoginAttemptService.record)
* 403 응답으로 종료

여기서 중요한 점은 “인증은 성공했지만 서비스 정책으로 로그인은 실패”가 가능하다는 것.
그리고 이건 SuccessHandler가 가장 자연스럽게 처리할 수 있는 케이스다.

### (4) 로그인 시도 감사 로그 기록

성공/실패 모두 record를 남긴다.

이 데이터는 이후 관리자 화면에서:

* 특정 유저의 최근 로그인 실패/성공 추적
* 공격 탐지(특정 IP/디바이스 반복 시도)
  에 바로 쓰인다.

### (5) 디바이스 upsert + 세션 매핑 저장

* userDeviceService.upsertLogin(...)로 로그인 디바이스/UA/IP 업데이트
* sessionMapService.bind(...)로 세션-유저-디바이스- provider 매핑 저장

이 매핑이 있어야 “특정 세션 강제 종료”, “기기별 세션 강제 종료” 같은 운영 기능이 깔끔해진다.

### (6) returnUrl redirect

OAuth는 브라우저 기반 흐름이 많으므로, 로그인 전 저장해둔 returnUrl로 redirect 하는 패턴이 자연스럽다.

---

## 6-3. (선택) OAuth2AuthorizedClientService로 토큰 접근

프로젝트 코드에 주석으로 남긴 것처럼:

* `OAuth2AuthorizedClientService.loadAuthorizedClient(...)`로
* access token/refresh token을 꺼낼 수 있다

다만 저장하려면 반드시:

* 암호화 정책
* 만료/갱신 전략
* 유출 대응
  이 따라야 해서 “필요할 때만” 활성화하는 편이 안전하다.

---

# 7) OAuth 로그아웃은 어떻게 처리해야 할까

OAuth “로그아웃”은 보통 두 의미가 섞인다.

* 우리 서비스 세션/토큰을 끊는 것
* 플랫폼 세션까지 끊는 것

대부분의 서비스는 기본적으로 “우리 서비스 인증만 해제”한다.

* 세션 기반이면 LogoutFilter + LogoutHandler로 세션 제거
* JWT 기반이면 denylist에 토큰 등록

플랫폼 로그아웃까지 하려면 provider별 endpoint와 정책이 다르니 별도 설계가 필요하다.

---
